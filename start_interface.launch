1. file start_interface.launch
<launch>
    <node name="sim_manager_node" pkg="waiterbot_gui" type="sim_manager.py" output="screen" />

    <node name="gui_node" pkg="waiterbot_gui" type="gui_app.py" output="screen" />

</launch>

2. sim_manager.py
#!/usr/bin/env python3
import rospy
import subprocess
import os
import signal
from std_msgs.msg import String

# Variabel global untuk menyimpan proses yang sedang berjalan
gazebo_process = None
navigation_process = None

def stop_simulation():
    """Menghentikan semua proses simulasi yang sedang berjalan."""
    global gazebo_process, navigation_process

    # Hentikan navigasi terlebih dahulu
    if navigation_process:
        rospy.loginfo("Menghentikan proses navigasi...")
        os.killpg(os.getpgid(navigation_process.pid), signal.SIGINT)
        navigation_process.wait()
        navigation_process = None

    # Kemudian hentikan Gazebo
    if gazebo_process:
        rospy.loginfo("Menghentikan proses Gazebo...")
        os.killpg(os.getpgid(gazebo_process.pid), signal.SIGINT)
        gazebo_process.wait()
        gazebo_process = None
    rospy.loginfo("Semua simulasi telah dihentikan.")

def start_simulation(map_name):
    """Memulai Gazebo dan stack navigasi."""
    global gazebo_process, navigation_process

    stop_simulation() # Selalu hentikan yang lama sebelum memulai yang baru
    rospy.sleep(2) # Beri jeda singkat

    ros_env = os.environ.copy()

    try:
        # --- 1. Jalankan Gazebo ---
        # Perintah ini akan meluncurkan dunia virtual dan model robot TurtleBot3
        gazebo_command = ["roslaunch", "turtlebot3_gazebo", "turtlebot3_world.launch"]
        rospy.loginfo("Manajer: Menjalankan Gazebo...")
        gazebo_process = subprocess.Popen(gazebo_command, env=ros_env, preexec_fn=os.setsid)

        # --- Beri waktu yang cukup agar Gazebo siap ---
        rospy.loginfo("Manajer: Menunggu Gazebo siap selama 10 detik...")
        rospy.sleep(10)

        # --- 2. Jalankan Navigasi (termasuk Rviz dan map_server) ---
        # Perintah ini akan memuat peta, AMCL, move_base, dan Rviz
        nav_command = ["roslaunch", "turtlebot3_navigation", "turtlebot3_navigation.launch"]
        rospy.loginfo("Manajer: Menjalankan Navigasi...")
        navigation_process = subprocess.Popen(nav_command, env=ros_env, preexec_fn=os.setsid)

        rospy.loginfo("Manajer: Simulasi Gazebo dan Navigasi telah dieksekusi.")

    except Exception as e:
        rospy.logerr(f"Gagal menjalankan roslaunch: {e}")

def callback(msg):
    rospy.loginfo(f"Manajer: Menerima permintaan untuk peta '{msg.data}'")
    start_simulation(msg.data)

def main():
    rospy.init_node('sim_manager_node')
    rospy.Subscriber('/gui/select_map', String, callback)
    rospy.loginfo("Manajer Simulasi (Gazebo) siap.")
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        stop_simulation()

3. gui_app.py
#!/usr/bin/env python3
import threading
import rospy
from std_msgs.msg import String
from nav_msgs.msg import OccupancyGrid
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.image import Image
from kivy.graphics.texture import Texture
from kivy.clock import mainthread
import numpy as np
import signal # Import modul signal

class MapWidget(Image):
    @mainthread
    def update_map_texture(self, map_data, width, height):
        if self.texture is None or self.texture.size != (width, height):
            self.texture = Texture.create(size=(width, height), colorfmt='luminance')
        
        map_data_flipped = np.flipud(map_data)
        self.texture.blit_buffer(map_data_flipped.tobytes(), colorfmt='luminance', bufferfmt='ubyte')
        self.canvas.ask_update()

class GuiApp(App):
    def __init__(self, **kwargs):
        super(GuiApp, self).__init__(**kwargs)
        self.map_publisher = rospy.Publisher('/gui/select_map', String, queue_size=10, latch=True)
        self.map_subscriber = rospy.Subscriber('/map', OccupancyGrid, self.on_map_received)
        rospy.loginfo("GUI Kivy: Publisher & Subscriber siap.")
        self.map_widget = None

    def build(self):
        self.title = "Waiter-Bot Control"
        layout = BoxLayout(orientation='vertical')
        btn = Button(text="Jalankan Simulasi & Tampilkan Peta", size_hint_y=0.1)
        btn.bind(on_press=self.run_simulation)
        self.map_widget = MapWidget()
        
        layout.add_widget(btn)
        layout.add_widget(self.map_widget)
        return layout

    def run_simulation(self, instance):
        self.map_publisher.publish("turtlebot_world")
        print("GUI: Mengirim perintah 'turtlebot_world'")

    def on_map_received(self, msg):
        width = msg.info.width
        height = msg.info.height
        data = np.array(msg.data, dtype=np.uint8)

        data[data == -1] = 127 
        data[data == 0] = 255
        data[data == 100] = 0
        
        self.map_widget.update_map_texture(data, width, height)
        print("GUI: Peta diterima dan digambar.")

    def on_stop(self):
        # --- PERUBAHAN PENTING ---
        # Saat jendela Kivy ditutup, kirim sinyal shutdown ke ROS
        rospy.loginfo("Jendela Kivy ditutup, mengirim sinyal shutdown ke ROS...")
        rospy.signal_shutdown("Aplikasi Kivy ditutup oleh pengguna")

def run_kivy_app_in_thread():
    GuiApp().run()

if __name__ == '__main__':
    rospy.init_node('gui_node', anonymous=True, disable_signals=True)
    rospy.loginfo("Node GUI utama telah diinisialisasi.")
    
    kivy_thread = threading.Thread(target=run_kivy_app_in_thread)
    kivy_thread.daemon = True
    kivy_thread.start()
    
    try:
        # Loop ini menjaga agar program utama (ROS) tetap berjalan
        # dan bisa menangkap Ctrl+C
        while kivy_thread.is_alive() and not rospy.is_shutdown():
            rospy.sleep(0.1)
    except KeyboardInterrupt:
        # --- PERUBAHAN PENTING ---
        # Jika pengguna menekan Ctrl+C di terminal, kirim sinyal shutdown
        rospy.loginfo("Ctrl+C terdeteksi, mengirim sinyal shutdown ke ROS...")
        rospy.signal_shutdown("Ctrl+C ditekan")
